<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>给Cartographer添加全局重定位功能</title>
      <link href="/2023-08/766593009d87/"/>
      <url>/2023-08/766593009d87/</url>
      
        <content type="html"><![CDATA[<p>新版本的 Cartographer 是没有初始全局重定位的功能的，不过旧版本中有提供一个简单的实现参考，可以看我先前的文章<a href="https://zjlian.github.io/2023-08/b75611994b01/">《Cartographer中的简易全局重定位方法》</a>。但是在旧版源码中并没有实际使用这个函数。</p><p>下面将会介绍如何在新版 carto 中添加上全局重定位功能，并提供接口供 cartographer_ros 调用。同时也会介绍如何用 carto 自带的线程池加速重定位的计算。</p><p>可以先看看原版重定位函数的实现，我删除了一些检查和日志，只关注核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PerformGlobalLocalization</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> <span class="type">float</span> cutoff,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> cartographer::sensor::AdaptiveVoxelFilter&amp; voxel_filter,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::vector&lt;cartographer::mapping_2d::scan_matching::FastCorrelativeScanMatcher*&gt;&amp; matchers,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> cartographer::sensor::PointCloud&amp; point_cloud,</span></span></span><br><span class="line"><span class="params"><span class="function">    transform::Rigid2d* <span class="type">const</span> best_pose_estimate, <span class="type">float</span>* <span class="type">const</span> best_score)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输入有效性检查 ...</span></span><br><span class="line">    *best_score = cutoff;</span><br><span class="line">    transform::Rigid2d pose_estimate;</span><br><span class="line">    <span class="comment">// 对输入点云做滤波</span></span><br><span class="line">    <span class="type">const</span> sensor::PointCloud filtered_point_cloud = voxel_filter.<span class="built_in">Filter</span>(point_cloud);</span><br><span class="line">    <span class="type">bool</span> success = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 遍历匹配器，对所有子图做全图匹配</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; matcher : matchers) &#123;</span><br><span class="line">        <span class="type">float</span> score = <span class="number">-1</span>;</span><br><span class="line">        transform::Rigid2d pose_estimate;</span><br><span class="line">        <span class="keyword">if</span> (matcher-&gt;<span class="built_in">MatchFullSubmap</span>(filtered_point_cloud, *best_score, &amp;score, &amp;pose_estimate)) &#123;</span><br><span class="line">            *best_score = score;</span><br><span class="line">            *best_pose_estimate = pose_estimate;</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，原版的实现真的很简单，就是拿一帧点云，对每一幅 Submap 都做一次全图匹配。这里用的匹配器 <code>FastCorrelativeScanMatcher</code> 是 carto 用来做回环检测的匹配器，匹配的成功率还是很不错的，不过匹配后还位姿还会差一点点才能对上，需要再调用一次 <code>CeresScanMatcher2D</code> 匹配器进行精确匹配得到正确的位姿。</p><h2 id="全局重定位功能实现过程"><a href="#全局重定位功能实现过程" class="headerlink" title="全局重定位功能实现过程"></a>全局重定位功能实现过程</h2><p>因为全局重定位需要读取所有的 Submap 数据和最新的点云数据，所以把代码加在 <code>pose_graph_2d</code> 模块里是最方便的，cartographer_ros 里也能调用到。</p><p>首先就是接口的定义，cartographer_ros 里能通过 <code>MapBuilderBridge</code> 访问到 carto 的 <code>MapBuilder</code> 实例，而 <code>MapBuilder</code> 又能访问到 <code>PoseGraph2D</code>，所以我们只需要在 <code>PoseGraphInterface</code> 接口类中添加全局重定位的虚函数，然后在他的派生类中添加对应的实现。</p><p><code>PoseGraphInterface</code> 中添加的全局重定位的接口，我们的接口不需要传入点云滤波器，内部直接调体素滤波就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件 cartographer\mapping\pose_graph.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PoseGraphInterface</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">PerformGlobalLocalization</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">float</span> cutoff, <span class="type">const</span> cartographer::sensor::PointCloud&amp; point_cloud,</span></span></span><br><span class="line"><span class="params"><span class="function">      transform::Rigid2d* best_pose_estimate, <span class="type">float</span>* best_score)</span> </span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后到 <code>PoseGraph2D</code> 里添加对应的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件 cartographer\mapping\internal\2d\pose_graph_2d.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PoseGraph2D</span> : <span class="keyword">public</span> PoseGraph </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">PerformGlobalLocalization</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">float</span> cutoff, <span class="type">const</span> cartographer::sensor::PointCloud&amp; point_cloud,</span></span></span><br><span class="line"><span class="params"><span class="function">        transform::Rigid2d* best_pose_estimate, <span class="type">float</span>* best_score)</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>到这里先介绍一下这个重定位函数的流程，然后逐个部分给出实现代码。</p><ol><li>创建线程池；</li><li>点云过一次体素滤波；</li><li>为每一个 Submap 创建 FastCorrelativeScanMatcher 匹配器，在线程池中执行，并等待所有匹配器创建完成；</li><li>遍历每一个匹配器，调用 MatchFullSubmap 方法，记录匹配结果和分数，在线程池中执行，并等待所有匹配完成；</li><li>找出匹配得分最高的位姿，创建 CeresScanMatcher2D 匹配器再次匹配得到准确的位姿。</li></ol><p>无论是创建匹配器还是全图匹配，计算量都很大，使用线程池来执行这些操作是必要的，这里直接用 carto 本身的线程池。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pool = std::<span class="built_in">make_unique</span>&lt;common::ThreadPool&gt;(std::thread::<span class="built_in">hardware_concurrency</span>());</span><br><span class="line"><span class="built_in">assert</span>(pool != <span class="literal">nullptr</span>);</span><br></pre></td></tr></table></figure><p>点云滤波也是必须的，一两千个点云的计算量非常大，按 0.05 米的参数过一遍体素滤波后只剩几百个点，计算结果几乎也没差别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> sensor::PointCloud filtered_point_cloud = sensor::<span class="built_in">VoxelFilter</span>(<span class="number">0.05</span>).<span class="built_in">Filter</span>(point_cloud);</span><br></pre></td></tr></table></figure><p>接着是为每一幅 Submap 创建匹配器，这一步需要在线程池里加速执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> submap_size = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(data_.submap_data.<span class="built_in">size</span>());</span><br><span class="line">absl::BlockingCounter created_counter&#123;submap_size&#125;;</span><br><span class="line">std::vector&lt;std::shared_ptr&lt;scan_matching::FastCorrelativeScanMatcher2D&gt;&gt; matchers;</span><br><span class="line">std::vector&lt;<span class="type">const</span> cartographer::mapping::Grid2D*&gt; submaps;</span><br><span class="line">matchers.<span class="built_in">resize</span>(submap_size);</span><br><span class="line">submaps.<span class="built_in">resize</span>(submap_size);</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; submap_id_data : data_.submap_data) &#123;</span><br><span class="line">    <span class="keyword">if</span> (submap_id_data.id.trajectory_id != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> task = std::<span class="built_in">make_unique</span>&lt;common::Task&gt;();</span><br><span class="line">    task-&gt;<span class="built_in">SetWorkItem</span>([<span class="keyword">this</span>, &amp;matchers, &amp;created_counter, index, submap_id = submap_id_data.id, &amp;submaps] &#123;</span><br><span class="line">        submaps.<span class="built_in">at</span>(index) = <span class="built_in">static_cast</span>&lt;<span class="type">const</span> Submap2D*&gt;(data_.submap_data.<span class="built_in">at</span>(submap_id).submap.<span class="built_in">get</span>())-&gt;<span class="built_in">grid</span>();</span><br><span class="line">        matchers.<span class="built_in">at</span>(index) =  std::<span class="built_in">make_unique</span>&lt;scan_matching::FastCorrelativeScanMatcher2D&gt;(</span><br><span class="line">            *(submaps.<span class="built_in">at</span>(index)),</span><br><span class="line">            options_.<span class="built_in">constraint_builder_options</span>().<span class="built_in">fast_correlative_scan_matcher_options</span>());</span><br><span class="line">        created_counter.<span class="built_in">DecrementCount</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    pool-&gt;<span class="built_in">Schedule</span>(std::<span class="built_in">move</span>(task));</span><br><span class="line">    index++;</span><br><span class="line">&#125;</span><br><span class="line">created_counter.<span class="built_in">Wait</span>();</span><br></pre></td></tr></table></figure><p>匹配器创建好之后就是调用全图匹配了，这一步同样需要在线程池里执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储所有匹配分数和结果</span></span><br><span class="line">std::vector&lt;<span class="type">float</span>&gt; score_set;</span><br><span class="line">std::vector&lt;transform::Rigid2d&gt; pose_set;</span><br><span class="line">score_set.<span class="built_in">resize</span>(submap_size);</span><br><span class="line">pose_set.<span class="built_in">resize</span>(submap_size);</span><br><span class="line">absl::BlockingCounter matched_counter&#123;submap_size&#125;;</span><br><span class="line">std::atomic_bool has_matched&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; matchers.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="comment">// 循环创建任务放入线程池</span></span><br><span class="line">    <span class="keyword">auto</span> task = std::<span class="built_in">make_unique</span>&lt;common::Task&gt;();</span><br><span class="line">    task-&gt;<span class="built_in">SetWorkItem</span>([i, &amp;filtered_point_cloud, &amp;matchers, &amp;score_set, &amp;pose_set, cutoff, &amp;matched_counter] &#123;</span><br><span class="line">        <span class="type">float</span> score = <span class="number">-1</span>; </span><br><span class="line">        transform::Rigid2d pose_estimate;</span><br><span class="line">        <span class="keyword">if</span> (matchers[i]-&gt;<span class="built_in">MatchFullSubmap</span>(filtered_point_cloud, cutoff, &amp;score, &amp;pose_estimate)) &#123;</span><br><span class="line">            score_set.<span class="built_in">at</span>(i) = score;</span><br><span class="line">            pose_set.<span class="built_in">at</span>(i) = pose_estimate;</span><br><span class="line">            has_matched = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        matched_counter.<span class="built_in">DecrementCount</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">    pool-&gt;<span class="built_in">Schedule</span>(std::<span class="built_in">move</span>(task));</span><br><span class="line">&#125;</span><br><span class="line">matched_counter.<span class="built_in">Wait</span>();</span><br><span class="line"><span class="keyword">if</span> (!has_matched)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> has_matched;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历结果，找出分数最高的位姿</span></span><br><span class="line"><span class="type">int</span> max_position = <span class="built_in">max_element</span>(score_set.<span class="built_in">begin</span>(), score_set.<span class="built_in">end</span>()) - score_set.<span class="built_in">begin</span>();</span><br><span class="line">*best_score = score_set[max_position];</span><br><span class="line">*best_pose_estimate = pose_set[max_position];</span><br></pre></td></tr></table></figure><p>FastCorrelativeScanMatcher2D 匹配器找出可能性最高的位姿后，就是最后一步使用 CeresScanMatcher2D 匹配器去匹配精确位姿了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> csm = std::<span class="built_in">make_unique</span>&lt;scan_matching::CeresScanMatcher2D&gt;(</span><br><span class="line">    options_.<span class="built_in">constraint_builder_options</span>().<span class="built_in">ceres_scan_matcher_options</span>());</span><br><span class="line">ceres::Solver::Summary unused_summary;</span><br><span class="line">csm-&gt;<span class="built_in">Match</span>(best_pose_estimate-&gt;<span class="built_in">translation</span>(), *best_pose_estimate,</span><br><span class="line">           filtered_point_cloud, *(submaps.<span class="built_in">at</span>(max_index)),</span><br><span class="line">           best_pose_estimate, &amp;unused_summary);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> has_matched;</span><br></pre></td></tr></table></figure><p>使用方法也很简单，我用的方法是纯定位模式启动后，等加载完 pbstream 地图文件和缓存有效一帧点云数据，通过 <code>MapBuilderBridge</code> 暴露的接口调用全局重定位函数，得到有效的匹配位姿后缓存起来，然后析构掉当前的 Node 实例，重新构造一个并使用匹配到的位姿作为初始化位姿来重新开始纯定位模式。<br>可以把这个接口封装成一个RPC请求，grpc 或者是 ros service 都可以，外部调用请求，cartographer_ros 计算返回结果，然后外部再重启纯定位模式。</p><p>其实这个方法还是有缺陷的，它只能在机器人停在原地不动的时候才能用，不然等匹配完，机器人已经跑别的地方去了。</p><p>(●’◡’●)</p>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Cartographer中的简易全局重定位方法</title>
      <link href="/2023-08/b75611994b01/"/>
      <url>/2023-08/b75611994b01/</url>
      
        <content type="html"><![CDATA[<p>这两天上网冲浪的时候看到有人说 Cartographer 里有一个 PerformGlobalLocalization 函数用于全局重定位，可以看 cartographer github 仓库的 Issue #95  Localization in Existing Map。</p><p>不过我在源码里搜了一下并没有发现这个函数，然后又把旧版本的源码也搜了一下，发现在0.3.0版本之后被删除了，同时新版本中也提供了 pure_localization 模式，函数被删除应该和这个有点关系。</p><p>在 0.3.0 或更早的版本中能找到叫 fast_global_localizer.h&#x2F;.cpp 的文件，PerformGlobalLocalization 函数就在里面，函数声明如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Perform global localization against the provided &#x27;matchers&#x27;. The &#x27;cutoff&#x27;</span></span><br><span class="line"><span class="comment">// specifies the minimum correlation that will be accepted.</span></span><br><span class="line"><span class="comment">// This function does not take ownership of the pointers passed in</span></span><br><span class="line"><span class="comment">// &#x27;matchers&#x27;; they are passed as a vector of raw pointers to give maximum</span></span><br><span class="line"><span class="comment">// flexibility to callers.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Returns true in the case of successful localization. The output parameters</span></span><br><span class="line"><span class="comment">// should not be trusted if the function returns false. The &#x27;cutoff&#x27; and</span></span><br><span class="line"><span class="comment">// &#x27;best_score&#x27; are in the range [0., 1.].</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PerformGlobalLocalization</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">float</span> cutoff, <span class="type">const</span> cartographer::sensor::AdaptiveVoxelFilter&amp; voxel_filter,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::vector&lt;</span></span></span><br><span class="line"><span class="params"><span class="function">        cartographer::mapping_2d::scan_matching::FastCorrelativeScanMatcher*&gt;&amp;</span></span></span><br><span class="line"><span class="params"><span class="function">        matchers,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> cartographer::sensor::PointCloud&amp; point_cloud,</span></span></span><br><span class="line"><span class="params"><span class="function">    transform::Rigid2d* best_pose_estimate, <span class="type">float</span>* best_score)</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数共有4个输入和3个输出：</p><p><strong>cutoff</strong>          最低的匹配有效分数；<br><strong>voxel_filter</strong>    点云滤波器；<br><strong>matchers</strong>        FastCorrelativeScanMatcher 匹配器，需要匹配多少副 Submap 就传入多少个；<br><strong>point_cloud</strong>     等待匹配的点云；   </p><p><strong>best_pose_estimate</strong>  匹配到的最佳位姿；<br><strong>best_score</strong>          匹配结果的分数；<br><strong>return</strong>              是否有匹配结果；   </p><p>函数的实现部分非常简单，就是一种 sacn-to-map 的匹配方法，先把点云过一遍滤波后，再逐个调用传入的 matcher 的 MatchFullSubmap 方法进行匹配，最后得到匹配得分最高的位姿和分数后返回。</p><p>PerformGlobalLocalization 函数存在一个很明显的缺陷啊，那就是可靠性不高，如果刚好传入的点云处在两个 Submap 的交界处，或者是多个 Submap 中纯在相似的结构，匹配的结果都有可能是错误的。我想在新版本中移除这个函数也是考虑到了这些问题，新版的 pure_localization 模式用 map-to-map 的方式来实现类似全局重定位的功能，虽然刚启动的时候要生成一定数量的 Submap 后才能触发当前轨迹与先验地图的轨迹的 map-to-map 匹配，但可靠性必然是比 PerformGlobalLocalization  要高得多的，不过也还是没能做到100%可靠。</p><p>在新版本中抄一下这个函数用来加速开机的重定位速度应该也是不错的，在地图比较大的时候，这个函数计算量会很大，再做一些优化可能会更好：</p><p>（一）并行化改造，这个函数就是很粗暴的遍历每一个 matcher 去调用函数做匹配，完全可以并行去执行这个循环，最后再汇总结果取出分数最高的位姿。</p><p>（二）在有先验位姿的情况下缩小搜索范围，可以用一些简单的策略来提高匹配的可靠性，例如只对距离最近的三幅 Submap 做匹配，并且直接调用 FastCorrelativeScanMatcher 的 Match 函数，通过提供先验位姿和有限的搜索范围来匹配点云。</p><p>（三）和别的全局重定位方法做互补和交叉验证，例如有AMCL的时候，可以用 PerformGlobalLocalization 先计算出一个位姿作为 AMCL 全局搜索的先验输入，AMCL 得到结果后再对比两个值是否接近，利用词袋模型实现的视觉全局重定位也可以做类似的操作，提高匹配速度并交叉验证结果。</p><p>(●’◡’●)</p>]]></content>
      
      
      <categories>
          
          <category> SLAM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>收集一些不错的 c++ 相关视频资料</title>
      <link href="/2022-08/a8f27ed23c9d/"/>
      <url>/2022-08/a8f27ed23c9d/</url>
      
        <content type="html"><![CDATA[<p>视频大多来自油土鳖，需要特殊工具才能观看。</p><p><strong>视频学习顺序不分先后</strong></p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><h3 id="首推的必然是侯捷的系列视频"><a href="#首推的必然是侯捷的系列视频" class="headerlink" title="首推的必然是侯捷的系列视频"></a>首推的必然是侯捷的系列视频</h3><ul><li>C++ 面向对象高级开发<br><a href="https://www.youtube.com/watch?v=GIvZmTfvkJw&amp;list=PLRTJhCIMo8HOIpVXaaI_yqihTuSTPUcCy">https://www.youtube.com/watch?v=GIvZmTfvkJw&amp;list=PLRTJhCIMo8HOIpVXaaI_yqihTuSTPUcCy</a></li><li>C++11&#x2F;14 新语法新机制<br><a href="https://www.youtube.com/watch?v=4HZpY7X9RG4&amp;list=PLRTJhCIMo8HM16EbfTa4IgvwgLbj5z_9M">https://www.youtube.com/watch?v=4HZpY7X9RG4&amp;list=PLRTJhCIMo8HM16EbfTa4IgvwgLbj5z_9M</a></li><li>C++ 标准库<br><a href="https://www.youtube.com/watch?v=IoXNDKyI1L0&amp;list=PLRTJhCIMo8HPW3OA74uVWIFWDCGRVckUV">https://www.youtube.com/watch?v=IoXNDKyI1L0&amp;list=PLRTJhCIMo8HPW3OA74uVWIFWDCGRVckUV</a></li></ul><h3 id="CppCon-2014-Herb-Sutter-“Back-to-the-Basics-Essentials-of-Modern-C-Style”"><a href="#CppCon-2014-Herb-Sutter-“Back-to-the-Basics-Essentials-of-Modern-C-Style”" class="headerlink" title="CppCon 2014: Herb Sutter “Back to the Basics! Essentials of Modern C++ Style”"></a>CppCon 2014: Herb Sutter “Back to the Basics! Essentials of Modern C++ Style”</h3><p>CppCon 的 Back to the Basics 基础系列话题之一，如何编写现代风格的 C++ 代码。<br><a href="https://www.youtube.com/watch?v=xnqTKD8uD64">https://www.youtube.com/watch?v=xnqTKD8uD64</a></p><h3 id="CppCon-2015-Herb-Sutter-“Writing-Good-C-14…-By-Default”"><a href="#CppCon-2015-Herb-Sutter-“Writing-Good-C-14…-By-Default”" class="headerlink" title="CppCon 2015: Herb Sutter “Writing Good C++14… By Default”"></a>CppCon 2015: Herb Sutter “Writing Good C++14… By Default”</h3><p>与上一个视频类似，这个着重 C++14 的内容。<br><a href="https://www.youtube.com/watch?v=hEx5DNLWGgA">https://www.youtube.com/watch?v=hEx5DNLWGgA</a></p><h3 id="Back-to-Basics-Move-Semantics-Klaus-Iglberger-CppCon-2019"><a href="#Back-to-Basics-Move-Semantics-Klaus-Iglberger-CppCon-2019" class="headerlink" title="Back to Basics: Move Semantics - Klaus Iglberger - CppCon 2019"></a>Back to Basics: Move Semantics - Klaus Iglberger - CppCon 2019</h3><p>C++11 引入的移动语义和所有权机制，必看典中典（不懂移动语义可以说就是不懂 C++）。视频有两个部分。<br><a href="https://www.youtube.com/watch?v=St0MNEU5b0o">https://www.youtube.com/watch?v=St0MNEU5b0o</a><br><a href="https://www.youtube.com/watch?v=pIzaZbKUw2s">https://www.youtube.com/watch?v=pIzaZbKUw2s</a>   </p><h2 id="入门后"><a href="#入门后" class="headerlink" title="入门后"></a>入门后</h2><h3 id="C-高级教程-从零开始开发服务器框架-sylar"><a href="#C-高级教程-从零开始开发服务器框架-sylar" class="headerlink" title="[C++高级教程]从零开始开发服务器框架(sylar)"></a>[C++高级教程]从零开始开发服务器框架(sylar)</h3><p>设计和实现一个基于协程的异步网络库，还有后端开发的一些基本组件。看懂这视频需要一定的 Linux 系统编程和网络编程的基础知识，UP 主讲解的并不是很好（几乎没讲解），如果对系统编程和网络编程完全没概念的话是没法看的。<br><a href="https://www.bilibili.com/video/BV184411s7qF">https://www.bilibili.com/video/BV184411s7qF</a><br>网络编程入门推荐《TCP&#x2F;IP网络编程》（尹圣雨 著，金国哲 译）这本书，书里分别讲了 Windows 和 Linux 的 Api 用法，只看 Linux 部分就够了。   </p><h3 id="Design-Patterns-Facts-and-Misconceptions-Klaus-Iglberger-CppCon-2021"><a href="#Design-Patterns-Facts-and-Misconceptions-Klaus-Iglberger-CppCon-2021" class="headerlink" title="Design Patterns: Facts and Misconceptions - Klaus Iglberger - CppCon 2021"></a>Design Patterns: Facts and Misconceptions - Klaus Iglberger - CppCon 2021</h3><p>思考设计模式在 C++ 的正确实践，Java 派的设计模式并不适合一比一复刻到 C++ 里。<br><a href="https://www.youtube.com/watch?v=OvO2NR7pXjg">https://www.youtube.com/watch?v=OvO2NR7pXjg</a></p><h3 id="Breaking-Dependencies-The-SOLID-Principles-Klaus-Iglberger-CppCon-2020"><a href="#Breaking-Dependencies-The-SOLID-Principles-Klaus-Iglberger-CppCon-2020" class="headerlink" title="Breaking Dependencies: The SOLID Principles - Klaus Iglberger - CppCon 2020"></a>Breaking Dependencies: The SOLID Principles - Klaus Iglberger - CppCon 2020</h3><p>设计低耦合高内聚代码架构的基本原则。<br><a href="https://www.youtube.com/watch?v=Ntraj80qN2k">https://www.youtube.com/watch?v=Ntraj80qN2k</a></p><h3 id="Making-the-Most-Out-of-Your-Compiler-Danila-Kutenin-CppCon-2021"><a href="#Making-the-Most-Out-of-Your-Compiler-Danila-Kutenin-CppCon-2021" class="headerlink" title="Making the Most Out of Your Compiler - Danila Kutenin - CppCon 2021"></a>Making the Most Out of Your Compiler - Danila Kutenin - CppCon 2021</h3><p>了解编译器会做哪些优化（其实并不是很全面，仅仅是了解）<br><a href="https://www.youtube.com/watch?v=tckHl8M3VXM">https://www.youtube.com/watch?v=tckHl8M3VXM</a></p><h3 id="Branchless-Programming-in-C-Fedor-Pikus-CppCon-2021"><a href="#Branchless-Programming-in-C-Fedor-Pikus-CppCon-2021" class="headerlink" title="Branchless Programming in C++ - Fedor Pikus - CppCon 2021"></a>Branchless Programming in C++ - Fedor Pikus - CppCon 2021</h3><p>针对 CPU 分支预测失败率过高情况下的性能优化手法。分支预测是现代 CPU 的一个性能优化机制，在预测成功的情况下确实能大幅提升算力，但是面对一些不确定性过高的场景，预测失败后的回溯成本是非常恐怖的。<br><a href="https://www.youtube.com/watch?v=g-WPhYREFjk">https://www.youtube.com/watch?v=g-WPhYREFjk</a></p><h3 id="MIT-6-172-Performance-Engineering-of-Software-Systems-Fall-2018"><a href="#MIT-6-172-Performance-Engineering-of-Software-Systems-Fall-2018" class="headerlink" title="MIT 6.172 Performance Engineering of Software Systems, Fall 2018"></a>MIT 6.172 Performance Engineering of Software Systems, Fall 2018</h3><p>麻省理工学院的高性能计算入门公开课。可以学到如何根据硬件平台的特点编写最高性能的代码，充分榨取硬件的能力。涉及到基本的编码风格、CPU高速缓存的原理、多线程程序设计和并行计算算法入门等东西。<br><a href="https://www.youtube.com/watch?v=o7h_sYMk_oc&amp;list=PLUl4u3cNGP63VIBQVWguXxZZi0566y7Wf">https://www.youtube.com/watch?v=o7h_sYMk_oc&amp;list=PLUl4u3cNGP63VIBQVWguXxZZi0566y7Wf</a></p><h2 id="视频账号"><a href="#视频账号" class="headerlink" title="视频账号"></a>视频账号</h2><ul><li>CppCon<br>由 C++ 标准委员会与各大 C++ 重度使用企业发起的社区讨论组织。这个视频账号会发布他们的演讲视频。演讲覆盖范围非常广，从最基本的语言功能到深入到各个领域的实际案例都有涵盖。<br><a href="https://www.youtube.com/user/CppCon">https://www.youtube.com/user/CppCon</a></li><li>CppNow<br>著名 IDE 厂商 JetBrains 发起的 C++ 社区讨论组织。这个视频账号会发布他们的演讲视频。<br><a href="https://www.youtube.com/user/BoostCon">https://www.youtube.com/user/BoostCon</a></li><li>C++ Weekly With Jason Turner<br>每周分享 C++ 碎片知识。经常发布些奇奇怪怪的东西，看个乐呵。<br><a href="https://www.youtube.com/c/lefticus1">https://www.youtube.com/c/lefticus1</a></li><li>lazyparser<br>一个做开源编译器工作的组织（还是企业？），分享非常多编译器相关的东西。2022年7月开始更新《徒手写一个RISC-V编译器》系列视频，讲的挺好的，把观众当成完全不懂编译原理的小 baby 来教。<br><a href="https://space.bilibili.com/296494084">https://space.bilibili.com/296494084</a></li></ul><p>(●’◡’●)</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
          <category> 收集 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo 首页按标签或分类过滤文章</title>
      <link href="/2022-07/06feec1b6d26/"/>
      <url>/2022-07/06feec1b6d26/</url>
      
        <content type="html"><![CDATA[<p>有时候写了一些很水的文章，不太希望它出现在首页时，就需要这样的过滤功能。    </p><p>原本是想自己写的，简单修改了首页的 ejs 模板后，发现效果并不符合需求，按照 <code>_config.yml</code> 内的配置项，首页展示设置了分页，每页 10 篇文章，如果这里 10 篇都带有需要过滤的标签，最后会得到以一个空白的页面，特别蠢。</p><p>想要正确过滤，并且保证每页的文章数量都是设定数量，就必须从 hexo 的实现源码上下手。在我搜索 hexo 的拓展开发文档时，无意间发现我的需求早就有人实现了。</p><p>这个 hexo 拓展的名字叫 “hexo-generator-index2”。<br>github 链接：<a href="https://github.com/Jamling/hexo-generator-index2">https://github.com/Jamling/hexo-generator-index2</a></p><p>用法也很简单，安装命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-index2 --save</span><br></pre></td></tr></table></figure><p>安装后只需要在 <code>_config.yml</code> 文件内添加如下内容即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># index2 generator 配置首页文章过滤</span></span><br><span class="line"><span class="attr">index2_generator:</span></span><br><span class="line">  <span class="attr">exclude:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tag</span> <span class="string">灌水</span></span><br></pre></td></tr></table></figure><p>添加了上面的配置后，生成的首页就能过滤掉带有 “灌水” 标签的文章。</p><p>除了过滤还可以设置白名单，只有特定标签或分类的文章才出现在首页。更多的信息可以到 github 仓库上看。</p><p>(●’◡’●)</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 灌水 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>toy-redis 开发日记：支持自定义内容输出的断言宏</title>
      <link href="/2022-07/8b34d791ea5e/"/>
      <url>/2022-07/8b34d791ea5e/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本文将介绍 toy-redis 内使用的断言工具 <code>ASSERT_MSG</code>，这是一个支持 <code>std::cout</code> 风格输出打印的断言宏，极大的方便了断言失败时输出必要的调试信息到终端上。   </p><p>toy-redis 项目地址: <a href="https://github.com/TIDC/toy-redis">https://github.com/TIDC/toy-redis</a><br>ASSERT_MSG 源码: <a href="https://github.com/TIDC/toy-redis/blob/master/base/checker.hpp">https://github.com/TIDC/toy-redis/blob/master/base/checker.hpp</a></p><h2 id="目的和设想"><a href="#目的和设想" class="headerlink" title="目的和设想"></a>目的和设想</h2><p>c 语言标准库 &lt;assert.h&gt; 内提供的宏 <code>assert</code> 功能非常残疾，断言失败后只能简单把文件和行号输出到终端上。类似系统函数错误后，只能通过 <code>errno</code> 获取具体的错误码，还有错误码对应的描述，这些都无法在 <code>assert</code> 断言错误后体现出来。</p><p>那怎么办呢？</p><p>我想要的就是一个可以在断言失败后，输出条件、文件名、行号和自定义内容的东西。想象中的用法是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ASSERT_MSG</span>(some_condition) </span><br><span class="line">    &lt;&lt; <span class="string">&quot;XXX 条件的需要满足 XXX，当前的值为 &quot;</span> &lt;&lt; XXX;</span><br></pre></td></tr></table></figure><p>断言失败后可以输出类似这样的信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[!!!!!! ASSERT &#x27;some_condition&#x27; ERROR !!!!!!]</span><br><span class="line">location: /xx/main.cpp:21 main</span><br><span class="line">what: XXX 条件的需要满足 XXX，当前的值为 ...</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>目前第一版的实现先不考虑 Release 模式下的开销问题，这个有的是办法做到零开销。</p><p>回看一下断言宏 <code>ASSERT_MSG</code> 的用法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ASSERT_MSG</span>(some_condition) </span><br><span class="line">    &lt;&lt; <span class="string">&quot;XXX 条件的需要满足 XXX，当前的值为 &quot;</span> &lt;&lt; XXX;</span><br></pre></td></tr></table></figure><p>与普通的断言宏 <code>assert</code> 类似，如果条件为真那就啥都不干，条件为假就输出日志并提前结束程序。<br><code>assert</code> 宏展开后是一个三元表达式，当条件为真时返回一个无意义的 void 值，条件为假时调用一个返回值为 void 的日志输出函数。</p><p><code>ASSERT_MSG</code> 需要特殊处理的是当条件为真时，后续的 operator&lt;&lt; 运算符和日志内容依旧存在，需要确保这些语句能够正确编译，但又不会输出内容到终端上。这一点与 <code>assert</code> 有所不同。    </p><p>我的做法是无论条件真假，都返回一个支持 operator&lt;&lt; 运算符的对象，但只有条件为假时才会输出日志，并且在对象析构时结束程序。<br>这个对象的类我取名为 <code>AbortOutputStream</code>，内部就是简单封装一下 <code>std::cerr</code>。先看声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AbortOutputStream</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 接受一个布尔值，表面是否输出日志和结束程序</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">AbortOutputStream</span><span class="params">(<span class="type">bool</span> work)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function">    <span class="comment">/// 析构函数内会结束程序</span></span></span><br><span class="line"><span class="function">    ~<span class="title">AbortOutputStream</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/// 流式风格输出的实现，因为需要</span></span></span><br><span class="line"><span class="function">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    AbortOutputStream &amp;<span class="keyword">operator</span>&lt;&lt;<span class="params">(<span class="type">const</span> T &amp;item)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/// 额外的输出方式</span></span></span><br><span class="line"><span class="function">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span></span><br><span class="line"><span class="function">    AbortOutputStream &amp;<span class="title">Print</span><span class="params">(<span class="type">const</span> T &amp;item, <span class="type">const</span> Ts... items)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="comment">/// 额外的输出方式</span></span></span><br><span class="line"><span class="function">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">    AbortOutputStream &amp;<span class="title">Print</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">private</span>:</span></span><br><span class="line"><span class="function">        bool work_ =</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">size_t</span> output_count_ = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>构造函数 <code>AbortOutputStream(bool work)</code> 会接受一个布尔值并初始化成员变量 <code>work_</code>，这个值非常关键，决定了是否会输出日志和结束程序。   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">AbortOutputStream</span><span class="params">(<span class="type">bool</span> work)</span></span></span><br><span class="line"><span class="function">    : work_(work) &#123;</span>&#125;</span><br></pre></td></tr></table></figure><p>析构函数 <code>~AbortOutputStream()</code> 内部会根据 <code>work_</code> 的值是否为真，决定要不要结束程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">~<span class="built_in">AbortOutputStream</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (work_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 先输出个换行和刷新缓冲区</span></span><br><span class="line">        std::cerr &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">/// 然后结束程序</span></span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现日志输的出部分比较奇葩，日志信息主要分为两个部分，第一个部分是错误的条件和位置，另一个部分是用户自定义的日志内容。在有用户自定义输出内容是是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[!!!!!! ASSERT &#x27;some_condition&#x27; ERROR !!!!!!]</span><br><span class="line">location: /xx/main.cpp:21 main</span><br><span class="line">what: XXX 条件的需要满足 XXX，当前的值为 ...</span><br></pre></td></tr></table></figure><p>没有时是这样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[!!!!!! ASSERT &#x27;some_condition&#x27; ERROR !!!!!!]</span><br><span class="line">location: /xx/main.cpp:21 main</span><br></pre></td></tr></table></figure><p><code>AbortOutputStream</code> 实现中的两个 <code>Print</code> 函数正是用来输出错误的条件和位置部分，由于需要输出任意类型任意数量的内容，实现 <code>Print</code> 需要用到模板元编程的一些技巧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 接受任意数量参数的 Print 是一个递归函数，他会递归调用自己，</span></span><br><span class="line"><span class="comment">/// 直到参数包 items 只剩下一个元素，这时候就会重载到另一个只接受一个参数的 Print 函数作为递</span></span><br><span class="line"><span class="comment">/// 归的结束条件。</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function">AbortOutputStream &amp;<span class="title">Print</span><span class="params">(<span class="type">const</span> T &amp;item, <span class="type">const</span> Ts &amp;...items)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (work_)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; item;</span><br><span class="line">        <span class="built_in">Print</span>(items...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Print 函数的递归结束条件重载</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">AbortOutputStream &amp;<span class="title">Print</span><span class="params">(<span class="type">const</span> T &amp;item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (work_)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(●’◡’●)</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
          <category> 造轮子 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>[CMU 数据库系统] Lecture #01: Relational Model &amp; Relational Algebra</title>
      <link href="/2022-07/da5eb91c3065/"/>
      <url>/2022-07/da5eb91c3065/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文是卡内基梅隆大学（CMU）的公开课 《Database System》的课件的翻译<br>第一课：关系模型与关系代数<br>原文链接：<a href="https://15445.courses.cs.cmu.edu/fall2021/notes/01-introduction.pdf">https://15445.courses.cs.cmu.edu/fall2021/notes/01-introduction.pdf</a><br>课程视频：<a href="https://www.youtube.com/watch?v=v4bU6n97Vr8&amp;list=PLSE8ODhjZXjZaHA6QcxDfJ0SIWBzQFKEG">https://www.youtube.com/watch?v=v4bU6n97Vr8&amp;list=PLSE8ODhjZXjZaHA6QcxDfJ0SIWBzQFKEG</a>   </p></blockquote><h2 id="1-Databases"><a href="#1-Databases" class="headerlink" title="1 Databases"></a>1 Databases</h2><p>数据库 (<em>database</em>) 是一个有组织的相互关联的数据集合，它用于对现实世界进行建模，例如建立学生与班级的关系模型，或者是一个数字音乐商店。我们口头上的叫法通常不会区分 “数据库” 与 “数据库管理系统 (<em>database management system</em>)” 之间的差别，实际上我们常用的数据库软件都应该被称作 “数据库管理系统”，而不是 “数据库”，这些软件有 MySQL、Oracle 和 MongoDB 等等，它们都是用来管理数据库的软件。</p><p>思考一下如何建模一个数字音乐商店，在数据库中存放艺人和这些艺人发布的专辑。</p><h2 id="2-Flat-File-Strawman"><a href="#2-Flat-File-Strawman" class="headerlink" title="2 Flat File Strawman"></a>2 Flat File Strawman</h2><p>先假设数据库管理系统里的数据库都是以 CSV 文件的形式存储的，每一个实体都存在他自己的文件里（实体是客观存在的事物，例如一个学生或者是一个教室，都是实体）。应用程序每次想要读取或者是更新时，都要解析整个文件。每一个实体可以拥有多个属性，因此在 CSV 文件中，每一行记录代表一个实体，而每一个记录中对应的属性使用逗号进行分隔。</p><p>继续电子音乐商店的例子，它需要两个数据库文件，一个存艺人信息，另一个存专辑信息。一位艺人拥有名字、年龄和国籍等属性，而一张专辑拥有名字、艺人和发行日期等属性。</p><blockquote><p>TODO: 提供点 CSV 表格的例子</p></blockquote><h3 id="CSV-文件作为数据库需要思考的问题"><a href="#CSV-文件作为数据库需要思考的问题" class="headerlink" title="CSV 文件作为数据库需要思考的问题"></a>CSV 文件作为数据库需要思考的问题</h3><ul><li><strong>数据完整性</strong><ul><li>…</li></ul></li><li><strong>如何使用</strong><ul><li>…</li></ul></li><li><strong>可靠性</strong><ul><li>…</li></ul></li></ul><h2 id="3-Database-Management-System"><a href="#3-Database-Management-System" class="headerlink" title="3 Database Management System"></a>3 Database Management System</h2><h2 id="4-Relational-Model"><a href="#4-Relational-Model" class="headerlink" title="4 Relational Model"></a>4 Relational Model</h2><h2 id="5-Data-Manipulation-Languages-DMLs"><a href="#5-Data-Manipulation-Languages-DMLs" class="headerlink" title="5 Data Manipulation Languages (DMLs)"></a>5 Data Manipulation Languages (DMLs)</h2><h2 id="6-Relational-Algebra"><a href="#6-Relational-Algebra" class="headerlink" title="6 Relational Algebra"></a>6 Relational Algebra</h2><h2 id="Observation"><a href="#Observation" class="headerlink" title="Observation"></a>Observation</h2><p>(●’◡’●)</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> CMU </category>
          
          <category> 翻译 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>分离 hexo 的 _posts 目录到独立仓库</title>
      <link href="/2022-07/987bb131dc00/"/>
      <url>/2022-07/987bb131dc00/</url>
      
        <content type="html"><![CDATA[<p>距离上一次搞 hexo 应该过去好几年了，最近突然又起了兴趣。今天便对着 hexo 的文档捣鼓了一下午，终于成功在 Github Pages 上部署了新的博客页面。在捣鼓的过程中也发现了一个不太完美的地方，那就是文章的源码是嵌入在 hexo 的源码里的，这一点让我非常难受啊。</p><p>后续捣鼓博客主题的时候，发现主题的源码都是通过 git 子模块添加到 hexo 源码内的，这时突然想到存放文章的目录 <code>source/_posts</code> 是不是也能给他搞成引用外部仓库的子模块呢？这样我就可以单独去维护和浏览文章的源码。如果哪天不想再用 hexo 了，直接把存 hexo 源码的仓库删了就完事了，反正我都文章都在另一个独立的仓库里。</p><p>简单验证了一下设想，确实是可行的，本文就记录一下 <code>source/_posts</code> 分离到一个独立仓库的方法。</p><h2 id="使用-hexo-搭建博客"><a href="#使用-hexo-搭建博客" class="headerlink" title="使用 hexo 搭建博客"></a>使用 hexo 搭建博客</h2><p>hexo 搭建博客和部署到 Github Pages 的过程看官方文档就行了，写得挺详细的，也有中文，直接看文档吧。<br><a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p><p>hexo 生成的静态页面我也是发布到一个独立的仓库里，命令一键发布的方式看这。<br><a href="https://github.com/hexojs/hexo-deployer-git">https://github.com/hexojs/hexo-deployer-git</a> </p><p>这部分内容百度谷歌都能查到很多资料，也不是本文的重点，我就不写了。</p><h2 id="分离-source-x2F-posts-目录"><a href="#分离-source-x2F-posts-目录" class="headerlink" title="分离 source&#x2F;_posts 目录"></a>分离 source&#x2F;_posts 目录</h2><p>hexo 的使用流程走完后，应该是能看到有个 <code>source/_posts</code> 目录的，这个目录用来存放文章的源码，我想做的就是把他配置成 git 子模块，指向一个独立的文章存储仓库。    </p><p>第一步肯定就是先建一个文章仓库，至于仓库放在哪都无所谓，github 也行，码云也行，是不是开源的也都无所谓，爱咋咋滴。<br>我是在 github 上建了个叫 “blog-posts” 的新仓库，仓库准备好了就可以进入下一步了。</p><p>第二步是进到 hexo 的源码目录，把 <code>source/_posts</code> 删掉，然后配置一下 git 子模块，把刚刚创建的 “blog-posts” 仓库添加进去，命令如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add git@github.com:zjlian/blog-posts.git <span class="built_in">source</span>/_posts</span><br></pre></td></tr></table></figure><p>命令中间的仓库链接部分 <code>git@github.com:zjlian/blog-posts.git</code> 自行替换成自己的博客仓库。</p><p>最后一步就是将修改后的 hexo 源码仓库提交到云端上去。   </p><p>很简单，到这里就完工了。   </p><h2 id="分离后怎么写文章"><a href="#分离后怎么写文章" class="headerlink" title="分离后怎么写文章"></a>分离后怎么写文章</h2><p>这部分比较灵活，想怎么用就怎么用，这里简单列两种用法。<br>（一）单独 clone 文章仓库下来写，这种用法需要自己手动编写 hexo 博客的 <a href="https://hexo.io/zh-cn/docs/front-matter">Front-matter</a> 信息，文章写完了，先提交文章仓库，然后到 hexo 仓库内用命令更新同步子模块，把最新的文章都下载下来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git submodule init</span><br><span class="line">git submodule update --remote --merge</span><br></pre></td></tr></table></figure><p>更新完后再敲一下部署命令 <code>hexo deploy</code> 就可以了。   </p><p>（二）第二种用法是直接在 hexo 仓库里写，用 hexo 的新建文章命令 <code>hexo new &#39;标题&#39;</code> 创建文章，写完后直接就能用命令 <code>hexo deploy</code> 部署，然后再进到 <code>source/_posts</code> 目录里把文章提交到云端仓库上。</p><p>用法没有什么固定的规则，可以根据自己的习惯和需求灵活变通。<br>有了习惯用法后可以写个脚本，自动完成重复工作。<br>也可以买台云服务器，捣鼓个 DevOps 服务出来，配合上 github 的 webhook，文章仓库提交更新后，让 github 自动给  DevOps 服务发请求，服务器收到请求后自动下载更新 hexo 仓库和文章仓库，再自动执行部署命令。</p><p>(●’◡’●)</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>测试</title>
      <link href="/2022-07/a18706653c0f/"/>
      <url>/2022-07/a18706653c0f/</url>
      
        <content type="html"><![CDATA[<h1 id="´▽-96-ʃ♡ƪ"><a href="#´▽-96-ʃ♡ƪ" class="headerlink" title="(´▽&#96;ʃ♡ƪ)"></a>(´▽&#96;ʃ♡ƪ)</h1>]]></content>
      
      
      <categories>
          
          <category> 灌水 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 灌水 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spdlog 用法</title>
      <link href="/2021-08/f758cf529ba9/"/>
      <url>/2021-08/f758cf529ba9/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="#%E5%9F%BA%E6%9C%AC%E6%9E%84%E6%88%90">基本构成</a><ul><li><a href="#struct-log_msg">struct log_msg</a></li><li><a href="#class-logger">class logger</a></li><li><a href="#class-sink">class sink</a></li><li><a href="#class-formatter">class formatter</a></li></ul></li><li><a href="#%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">基本工作流程</a></li><li><a href="#%E7%94%A8%E6%B3%95">用法</a><ul><li><a href="#%E4%B8%80%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E7%9A%84%E6%97%A5%E5%BF%97%E5%99%A8%E8%BF%9B%E8%A1%8C%E7%AE%80%E5%8D%95%E8%BE%93%E5%87%BA">（一）使用默认的日志器进行简单输出</a></li><li><a href="#%E4%BA%8C%E4%BD%BF%E7%94%A8%E5%AE%8F%E8%BE%93%E5%87%BA%E6%97%A5%E5%BF%97">（二）使用宏输出日志</a></li><li><a href="#%E4%B8%89%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F-%E5%92%8C-%E8%AE%BE%E7%BD%AE%E6%97%A5%E5%BF%97%E6%9C%89%E6%95%88%E7%BA%A7%E5%88%AB">（三）自定义日志格式 和 设置日志有效级别</a></li><li><a href="#%E5%9B%9B%E8%BE%93%E5%87%BA%E6%97%A5%E5%BF%97%E5%88%B0%E6%96%87%E4%BB%B6">（四）输出日志到文件</a></li><li><a href="#%E4%BA%94%E7%BB%84%E8%A3%85%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%97%A5%E5%BF%97%E5%99%A8">（五）组装自定义的日志器</a></li></ul></li></ul><h2 id="基本构成"><a href="#基本构成" class="headerlink" title="基本构成"></a>基本构成</h2><h3 id="struct-log-msg"><a href="#struct-log-msg" class="headerlink" title="struct log_msg"></a>struct log_msg</h3><p><strong>日志消息</strong>，用来存储日志信息的结构体，里面存了日志器名称、日志级别、创建时间、线程id和日志内容等信息。</p><h3 id="class-logger"><a href="#class-logger" class="headerlink" title="class logger"></a>class logger</h3><p><strong>日志器</strong>，直接面向用户的日志类，调用api输出日志。</p><h3 id="class-sink"><a href="#class-sink" class="headerlink" title="class sink"></a>class sink</h3><p><strong>输出器</strong>，负责将日志文本输出的类。这个类本身是个抽象类，spdlog基于他派生出了各种类型的输出器，例如输出到控制台的、输出到文件的。</p><p>一个logger可以拥有多个sink。也可以多个logger共享一个sink。</p><h3 id="class-formatter"><a href="#class-formatter" class="headerlink" title="class formatter"></a>class formatter</h3><p><strong>格式化器</strong>，负责将<code>log_msg</code>对象转换成最终要输出的字节数组。</p><p>每一个sink都拥有一个formatter。</p><p>spdlog维护了一个全局注册表，里面存储着全局共享的数据，当创建logger和sink时，默认使用的就是注册表里的formatter。</p><h2 id="基本工作流程"><a href="#基本工作流程" class="headerlink" title="基本工作流程"></a>基本工作流程</h2><p>当用户通过logger实例的info()、wram()等函数输出日志后，logger会使用fmt::format将用户传入的文本中的占位符”{}”替换成对应的参数，随后创建一个log_msg实例并传递给sink，sink输出前会调用formatter，根据指定的日志格式，对log_msg进行格式化，转换成字符数组后输出。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="（一）使用默认的日志器进行简单输出"><a href="#（一）使用默认的日志器进行简单输出" class="headerlink" title="（一）使用默认的日志器进行简单输出"></a>（一）使用默认的日志器进行简单输出</h3><p>spdlog提供了默认的全局日志器，使用下面的方法直接调用就可以了。</p><p><strong>例子：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spdlog::<span class="built_in">debug</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">spdlog::<span class="built_in">debug</span>(<span class="string">&quot;Hello &#123;&#125;&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">spdlog::<span class="built_in">info</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">spdlog::<span class="built_in">info</span>(<span class="string">&quot;Hello &#123;&#125;&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="comment">// spdlog 提供了7个等级的日志级别，分别为：</span></span><br><span class="line"><span class="comment">// trace, debug, info, warning, error, critical, off</span></span><br></pre></td></tr></table></figure><h3 id="（二）使用宏输出日志"><a href="#（二）使用宏输出日志" class="headerlink" title="（二）使用宏输出日志"></a>（二）使用宏输出日志</h3><p>用宏输出日志可以自动添加当前文件名称和代码行号等信息，方便调试。</p><p>spdlog默认情况下关闭了相关的宏，需要在头文件”spdlog.h”引入前，定义指定的宏开启该功能。使用方法如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SPDLOG_ACTIVE_LEVEL SPDLOG_LEVEL_INFO</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spdlog.h&quot;</span> <span class="comment">// SPDLOG_ACTIVE_LEVEL 的定义必须在这之前</span></span></span><br></pre></td></tr></table></figure><p>其中<code>SPDLOG_LEVEL_INFO</code>代表最低有效等级为INFO，低于该等级的日志宏将会不生效。spdlog为每一个日志级别都定义了对应的宏，可以按需求设置。这个宏只需要在mian()函数所在的文件定义一次就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SPDLOG_LEVEL_TRACE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPDLOG_LEVEL_DEBUG 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPDLOG_LEVEL_INFO 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPDLOG_LEVEL_WARN 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPDLOG_LEVEL_ERROR 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPDLOG_LEVEL_CRITICAL 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPDLOG_LEVEL_OFF 6</span></span><br></pre></td></tr></table></figure><p>使用宏输出日志时，需要显式指定用于输出的日志器，可以使用函数<code>spdlog::default_logger()</code>获取默认日志器的智能指针，也可以使用自己创建的日志器。</p><p><strong>例子：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SPDLOG_LOGGER_INFO</span>(spdlog::<span class="built_in">default_logger</span>(), <span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line"><span class="built_in">SPDLOG_LOGGER_INFO</span>(spdlog::<span class="built_in">default_logger</span>(), <span class="string">&quot;Hello &#123;&#125;&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="（三）自定义日志格式-和-设置日志有效级别"><a href="#（三）自定义日志格式-和-设置日志有效级别" class="headerlink" title="（三）自定义日志格式 和 设置日志有效级别"></a>（三）自定义日志格式 和 设置日志有效级别</h3><p>spdlog最终输出的日志格式是通过formatter进行格式化的，通过替换不同的formatter，即可实现对日志格式的控制。</p><p>spdlog提供了非常简易的方式配置日志格式，不需要我们手动构造formatter实例，只需要调用函数<code>set_pattern(&quot;..&quot;)</code>，并传入需要的格式化标记字符串即可。</p><p>例如，设置全局所有日志器的输出格式可以使用下面的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spdlog::<span class="built_in">set_pattern</span>(<span class="string">&quot;[%H:%M:%S][%n][thr %t][%s:%!():%#] %v&quot;</span>);</span><br></pre></td></tr></table></figure><p>这里摘抄一些比较常用的标记符，其他的可以去github看官方的wiki。</p><table><thead><tr><th>符号</th><th>作用</th></tr></thead><tbody><tr><td>%v</td><td>用户的日志文本</td></tr><tr><td>%t</td><td>线程id</td></tr><tr><td>%P</td><td>进程id</td></tr><tr><td>%n</td><td>日志器名称</td></tr><tr><td>%l</td><td>日志级别</td></tr><tr><td>%x</td><td>简略的日期 MM&#x2F;DD&#x2F;YY</td></tr><tr><td>%X</td><td>24小时制的时间，显示时分秒</td></tr><tr><td>%s</td><td>显示日志所在的文件的名称。需要使用spdlog提供的宏输出日志才有效果</td></tr><tr><td>%!</td><td>显示日志所在的函数的名称。需要使用spdlog提供的宏输出日志才有效果</td></tr><tr><td>%#</td><td>显示日志所在的行号。需要使用spdlog提供的宏输出日志才有效果</td></tr></tbody></table><p>需要注意的是<code>spdlog::set_pattern()</code>函数修改的是全局注册表里登记过的所有日志器。下一节会介绍到相关的东西。</p><p>spdlog还提供了设置有效日志级别的接口，低于指定级别的日志信息将会被忽略，不被输出。</p><p><strong>例子：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置全局默认日之器的输出级别</span></span><br><span class="line">spdlog::<span class="built_in">set_level</span>(spdlog::level::debug);</span><br></pre></td></tr></table></figure><p>每一个logger和sink都是可以单独设置日志格式和日志级别的，具体做法后面介绍。</p><h3 id="（四）输出日志到文件"><a href="#（四）输出日志到文件" class="headerlink" title="（四）输出日志到文件"></a>（四）输出日志到文件</h3><p>spdlog提供了一些工厂函数可以很方便的创建输出到文件的日志器。</p><p><strong>例子：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最基本的输出到文件的日志器</span></span><br><span class="line"><span class="keyword">auto</span> logger1 = spdlog::<span class="built_in">basic_logger_mt</span>(<span class="string">&quot;[logger_name]&quot;</span>, <span class="string">&quot;[file_name]&quot;</span>);</span><br><span class="line">logger1-&gt;<span class="built_in">info</span>(<span class="string">&quot;文件日志&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多文件轮流输出的日志器</span></span><br><span class="line"><span class="comment">// 第三个参数是单个文件最大字节数，第四个参数是最大文件数量</span></span><br><span class="line"><span class="comment">// 当一个文件大小到达单个文件最大字节数后，日志器就会创建新的文件继续输出，</span></span><br><span class="line"><span class="comment">// 直到文件数量到达设定的最大文件数量，这时就回到最早创建的文件，清空后继续输出。</span></span><br><span class="line"><span class="comment">// 输出的文件名称类似: file_name.1 file_name.2 file_name.3 file_name.4 ...</span></span><br><span class="line"><span class="keyword">auto</span> logger2 = spdlog::<span class="built_in">rotating_logger_mt</span>(<span class="string">&quot;[logger_name]&quot;</span>, <span class="string">&quot;[file_name]&quot;</span>, <span class="number">1024</span>, <span class="number">10</span>);</span><br><span class="line">logger2-&gt;<span class="built_in">info</span>(<span class="string">&quot;文件日志&quot;</span>);</span><br></pre></td></tr></table></figure><p>这些工厂函数都有个”_mt”后缀，这个后缀是 multi-thread 的缩写，代表该函数创建的日志器是多线程安全的。相反的，spdlog也提供了非线程安全的版本，只需要把后缀”_mt”改成”_st”即可，该版本去掉了所有的锁，用于单线程下获得更高的输出效率。</p><p>使用spdlog提供的工厂函数创建的日志器，会自动在spdlog维护的全局注册表中进行注册，使用<code>spdlog::get(&quot;[logger_name]&quot;)</code>函数，可以在程序的任何地方获取相同的日志器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> file_logger = spdlog::<span class="built_in">basic_logger_mt</span>(<span class="string">&quot;[logger_name]&quot;</span>, <span class="string">&quot;[file_name]&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> same_logger = spdlog::<span class="built_in">get</span>(<span class="string">&quot;[logger_name]&quot;</span>);</span><br><span class="line"><span class="comment">// file_logger 和 same_logger 是指向同一个日志器的指针</span></span><br></pre></td></tr></table></figure><h3 id="（五）组装自定义的日志器"><a href="#（五）组装自定义的日志器" class="headerlink" title="（五）组装自定义的日志器"></a>（五）组装自定义的日志器</h3><p>如果想要更加灵活的日志器，例如一个日志器按日志等级输出到终端或者不同的文件、多个日志器输出到同一个文件上、不同的文件使用不同的日志格式等等，都需要自己手动组装日志器来实现。</p><p>在命名空间<code>spdlog::sinks</code>下提供了大量预设的sink实现，可以直接使用这些预设的实现组合自己的logger。只需要引入对应的头文件即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spdlog/sinks/*.h&quot;</span></span></span><br></pre></td></tr></table></figure><p>创建一个输出到多个文件和控制台的logger。</p><p><strong>例子：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// spdlog完全使用c++11标准进行开发，logger、sink、formatter等实例对象均使用std::shared_ptr进行内存管理。</span></span><br><span class="line"><span class="comment">// 创建三个不同的sink，第一个是输出到控制台的，第二和第三个是分别输出到文件file1和file2的</span></span><br><span class="line"><span class="keyword">auto</span> console = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::stdout_color_sink_mt&gt;();</span><br><span class="line"><span class="keyword">auto</span> file1 = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::basic_file_sink_mt&gt;(<span class="string">&quot;logs/file1&quot;</span>);</span><br><span class="line"><span class="keyword">auto</span> file2 = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::basic_file_sink_mt&gt;(<span class="string">&quot;logs/file2&quot;</span>);</span><br><span class="line">std::vector&lt;spdlog::sink_ptr&gt; sinks;</span><br><span class="line">sinks.<span class="built_in">push_back</span>(console);</span><br><span class="line">sinks.<span class="built_in">push_back</span>(file1);</span><br><span class="line">sinks.<span class="built_in">push_back</span>(file2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// logger构造支持三种sink传递方式，分别是单个sink、传递容器范围、传递初始化列表</span></span><br><span class="line"><span class="comment">// 下面是使用容器范围的构造函数</span></span><br><span class="line"><span class="keyword">auto</span> mix_logger = std::<span class="built_in">make_shared</span>&lt;spdlog::logger&gt;(<span class="string">&quot;mix&quot;</span>, sinks.<span class="built_in">begin</span>(), sinks.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">// 下面是使用初始化列表的构造函数</span></span><br><span class="line"><span class="comment">// auto mix_logger = std::make_shared&lt;spdlog::logger&gt;(&quot;mix&quot;, &#123;console, file1, file2&#125;);</span></span><br><span class="line"><span class="comment">// 下面是单个sink的logger</span></span><br><span class="line"><span class="comment">// auto console_logger = std::make_shared&lt;spdlog::logger&gt;(&quot;mix&quot;, console);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    mix_logger-&gt;<span class="built_in">info</span>(<span class="string">&quot;12345678&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建输出到同一个文件的不同logger</p><p><strong>例子：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> file = std::<span class="built_in">make_shared</span>&lt;spdlog::sinks::basic_file_sink_mt&gt;(<span class="string">&quot;logs/file&quot;</span>);</span><br><span class="line"><span class="comment">// 使用同一个sink创建logger</span></span><br><span class="line"><span class="keyword">auto</span> file_logger1 = std::<span class="built_in">make_shared</span>&lt;spdlog::logger&gt;(<span class="string">&quot;logger1&quot;</span>, file);</span><br><span class="line"><span class="keyword">auto</span> file_logger2 = std::<span class="built_in">make_shared</span>&lt;spdlog::logger&gt;(<span class="string">&quot;logger2&quot;</span>, file);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    file_logger1-&gt;<span class="built_in">info</span>(<span class="string">&quot;12345678&quot;</span>);</span><br><span class="line">    file_logger2-&gt;<span class="built_in">info</span>(<span class="string">&quot;12345678&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个logger和sink的实例都提供了接口手动设置日志级别和日志格式。</p><p><strong>例子：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// logger设置日志格式。</span></span><br><span class="line"><span class="comment">// 需要注意，对一个logger设置日志格式，实际上是对这个logger拥有的全部sink设置日志格式。</span></span><br><span class="line">logger-&gt;<span class="built_in">set_pattern</span>(<span class="string">&quot;%v&quot;</span>);</span><br><span class="line"><span class="comment">// logger设置日志级别。</span></span><br><span class="line">logger-&gt;<span class="built_in">set_level</span>(spdlog::level::debug);</span><br><span class="line"></span><br><span class="line"><span class="comment">// sink 的和上面相同</span></span><br><span class="line">sink-&gt;<span class="built_in">set_pattern</span>(<span class="string">&quot;%v&quot;</span>);</span><br><span class="line">sink-&gt;<span class="built_in">set_level</span>(spdlog::level::debug);</span><br></pre></td></tr></table></figure><p>手动组装的日志器如果想要使用<code>spdlog::get(&quot;[logger_name]&quot;)</code>在任意地方获取，那就需要手动将创建好的日志器加入到spdlog的注册表中，方法也很简单，只需一行代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spdlog::<span class="built_in">register_logger</span>(mix_logger);</span><br><span class="line"><span class="comment">// 注册完成后，在程序的任何地方调用 spdlog::get() 都能拿到全局唯一对象的引用</span></span><br><span class="line"><span class="comment">// spdlog::get() 的参数为日志器构造时指定的名称</span></span><br><span class="line"><span class="keyword">auto</span> same_mix_logger = spdlog::<span class="built_in">get</span>(<span class="string">&quot;mix_logger&quot;</span>);</span><br></pre></td></tr></table></figure><p>(●’◡’●)</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快速泊松碟采样算法的 C++ 实现</title>
      <link href="/2021-05/f67819cc4eab/"/>
      <url>/2021-05/f67819cc4eab/</url>
      
        <content type="html"><![CDATA[<p>因为最近打工写的算法中，有一个步骤需要生成二维平面上生成一组均匀分布的随机点（任意两点的距离不能小于 r），一开始自己想了好多方法，结果实现出来后运行的效果，感觉自己像个小丑🤡一样。  </p><p>之后便花了点时间百度了一下，找到这个叫快速泊松碟采样（Fast Poisson Disc Sampling）的算法挺符合需求的，但百度上好像没有看到 C++ 的实现，于是我<del>抄</del>实现了个C++的版本作为参考。该版本没有考虑性能，只是能用。</p><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>算法的核心思想就是对二维平面进行分区，划分成一个个小区块，小区块的斜边长度为两点的间隔 r，因为斜边是一个正方形里最长线段，如果两个点同时出现在一个区块里，那他们的距离必然是小于 r 的，这样就是可以用区块标记表在 O(1) 的时间复杂度下查询出两个点的距离是否过近。算法名字中的 <strong>Fast</strong> 应该就体现在这里。   </p><p>算法的大致流程如下。想看算法出处的可以搜索文献 <strong>Fast Poisson Disk Sampling in Arbitrary Dimensions</strong> 看下。   </p><ol><li><p>根据间隔 r 划分区块</p></li><li><p>生成第一个随机点，将其加入结果集合和候选点集合中</p></li><li><p>从候选点集合中随机取一个点 P</p></li><li><p>以 P 为圆心，在半径 [r, 2r) 的圆内生成一个新的随机点 NewP</p></li><li><p>使用区块标记表查询 NewP 所在的区块是否已经存在随机点，查询计算周围8个区块的随机点与 NewP 的距离是否小于 r。如果 NewP不符合条件，回到步骤 4. 重复执行，直到成功或重试超过 30 次。</p></li><li><p>如果新随机点 NewP 采样成功，将 NewP 加入到结果集合和候选点集合中；如果失败，将 P 从候选点集合中移除</p></li><li><p>回到 3. ，直到候选点集合为空。</p></li></ol><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><p>代码实现需要先写一些准备工作的代码，比如描述“点”的向量类和一些随机数生成函数。</p><p>依赖的全部头文件如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdint&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure><p>描述点的向量如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vec2_</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OtherType&gt;</span></span><br><span class="line"><span class="function">    <span class="title">Vec2_</span><span class="params">(OtherType x, OtherType y)</span> </span></span><br><span class="line"><span class="function">        : x(static_cast&lt;T&gt;(x)), </span></span><br><span class="line"><span class="function">          y(static_cast&lt;T&gt;(y)) &#123;</span>&#125;</span><br><span class="line">    <span class="built_in">Vec2_</span>() : <span class="built_in">x</span>(<span class="number">0</span>), <span class="built_in">y</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OtherType&gt;</span></span><br><span class="line"><span class="function">    <span class="title">Vec2_</span><span class="params">(<span class="type">const</span> Vec2_&lt;OtherType&gt; &amp;rhs)</span> </span></span><br><span class="line"><span class="function">        : x(static_cast&lt;T&gt;(rhs.x)), </span></span><br><span class="line"><span class="function">          y(static_cast&lt;T&gt;(rhs.y)) </span></span><br><span class="line"><span class="function">    &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> OtherType&gt;</span><br><span class="line">    Vec2_&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Vec2_&lt;OtherType&gt; &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="built_in">static_cast</span>&lt;T&gt;(rhs.x);</span><br><span class="line">        y = <span class="built_in">static_cast</span>&lt;T&gt;(rhs.y);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Vec2_ &amp;pt) <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">return</span> (<span class="keyword">this</span>-&gt;x == pt.x &amp;&amp; <span class="keyword">this</span>-&gt;y == pt.y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Vec2_ <span class="keyword">operator</span>*(T n) <span class="type">const</span> &#123; <span class="keyword">return</span> &#123;x * n, y * n&#125;; &#125;</span><br><span class="line"></span><br><span class="line">    Vec2_ <span class="keyword">operator</span>+(T n) <span class="type">const</span> &#123; <span class="keyword">return</span> &#123;x + n, y + n&#125;; &#125;</span><br><span class="line"></span><br><span class="line">    Vec2_ <span class="keyword">operator</span>+(Vec2_ n) <span class="type">const</span> &#123; <span class="keyword">return</span> &#123;x + n.x, y + n.y&#125;; &#125;</span><br><span class="line"></span><br><span class="line">    Vec2_ <span class="keyword">operator</span>-(Vec2_ n) <span class="type">const</span> &#123; <span class="keyword">return</span> &#123;x - n.x, y - n.y&#125;; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取归一化的向量</span></span><br><span class="line">    <span class="function">Vec2_&lt;<span class="type">double</span>&gt; <span class="title">Normalized</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> len = <span class="built_in">Magnitude</span>();</span><br><span class="line">        <span class="keyword">if</span> (len != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> n = <span class="number">1</span> / len;</span><br><span class="line">            <span class="keyword">return</span> &#123;x * n, y * n&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取向量的长度</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">Magnitude</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>(x * x + y * y); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型转换</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> OtherType&gt;</span><br><span class="line">    <span class="keyword">operator</span> <span class="built_in">Vec2_</span>&lt;OtherType&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="built_in">static_cast</span>&lt;OtherType&gt;(x), <span class="built_in">static_cast</span>&lt;OtherType&gt;(y)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T x; <span class="comment">//坐标点的x值</span></span><br><span class="line">    T y; <span class="comment">//坐标点的y值</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Vec2_&lt;<span class="type">int32_t</span>&gt; Vec2Int32;</span><br><span class="line"><span class="keyword">typedef</span> Vec2_&lt;<span class="type">int64_t</span>&gt; Vec2Int64;</span><br><span class="line"><span class="keyword">typedef</span> Vec2_&lt;<span class="type">double</span>&gt; Vec2;</span><br></pre></td></tr></table></figure><p>伪随机数生成方面，由于C语言的 rand() 函数执行效率过于低下，严重影响算法的性能。C++ STL 的 mt19937 算法性能不错，但 API 组合起来比较复杂，当时一时半会儿还没太弄明白到底有多少种用法，那种用法更合适。</p><p>于是抄了个代码非常简短的 xor shift 伪随机数生成算法，性能也非常好。并且基于 xor shift 封装了几个需要的工具函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Random</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title">XorShift32</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint32_t</span> seed = <span class="built_in">time</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">uint32_t</span> x = seed;</span><br><span class="line">    x ^= x &lt;&lt; <span class="number">13</span>;</span><br><span class="line">    x ^= x &gt;&gt; <span class="number">17</span>;</span><br><span class="line">    x ^= x &lt;&lt; <span class="number">5</span>;</span><br><span class="line">    seed = x;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 [min, max) 区间内的随机整数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int32_t</span> <span class="title">Range</span><span class="params">(<span class="type">int32_t</span> min, <span class="type">int32_t</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">XorShift32</span>() + min) % max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 [0, max) 区间内的随机整数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int32_t</span> <span class="title">Range</span><span class="params">(<span class="type">int32_t</span> max)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Range</span>(<span class="number">0</span>, max);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取半径为 1 的圆内的随机点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Vec2 <span class="title">InsideUnitSphere</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> theta = <span class="built_in">Range</span>(<span class="number">360</span> * <span class="number">1000</span>) / <span class="number">1000.0</span>;</span><br><span class="line">    <span class="type">double</span> r = <span class="built_in">Range</span>(<span class="number">1000</span>) / <span class="number">1000.0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;(<span class="built_in">sqrt</span>(r) * <span class="built_in">cos</span>(theta)), (<span class="built_in">sqrt</span>(r) * <span class="built_in">sin</span>(theta))&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace Random</span></span><br></pre></td></tr></table></figure><p>快速泊松碟采样算法实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Random</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 快速泊松碟随机采样算法，在一定范围内生成均匀分布的随机点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> std::vector&lt;Vec2&gt; <span class="title">FastPoissonDiscSampling</span><span class="params">(Vec2 range, <span class="type">int32_t</span> threshold)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// boost::timer t;</span></span><br><span class="line">    std::vector&lt;Vec2&gt; list;</span><br><span class="line">    <span class="comment">// 重试次数上限</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int32_t</span> max_retry = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// n 的值等于 sqrt(维度)</span></span><br><span class="line">    <span class="keyword">auto</span> n = std::<span class="built_in">sqrt</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// threshold 除上 sqrt(2)，可用保证每一个区块的斜边长为 threshold，</span></span><br><span class="line">    <span class="comment">// 从而确保一个区块内的任意两个点的距离都是小于 threshold 的。</span></span><br><span class="line">    <span class="comment">// 利用这个特性可用快速的确定两个采样点的间距小于 threshold。</span></span><br><span class="line">    <span class="keyword">auto</span> cell_size = threshold / n;</span><br><span class="line">    <span class="comment">// 划分区块</span></span><br><span class="line">    <span class="type">int32_t</span> cols = std::<span class="built_in">ceil</span>(range.x / cell_size);</span><br><span class="line">    <span class="type">int32_t</span> rows = std::<span class="built_in">ceil</span>(range.y / cell_size);</span><br><span class="line">    <span class="comment">// 区块矩阵</span></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int32_t</span>&gt;&gt; grids;</span><br><span class="line">    grids.<span class="built_in">resize</span>(rows);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;row : grids)</span><br><span class="line">    &#123;</span><br><span class="line">        row.<span class="built_in">resize</span>(cols, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始</span></span><br><span class="line">    <span class="comment">// 随机选一个初始点</span></span><br><span class="line">    <span class="keyword">auto</span> start = Vec2&#123;Random::<span class="built_in">Range</span>(range.x), Random::<span class="built_in">Range</span>(range.y)&#125;;</span><br><span class="line">    <span class="type">int32_t</span> col = std::<span class="built_in">floor</span>(start.x / cell_size);</span><br><span class="line">    <span class="type">int32_t</span> row = std::<span class="built_in">floor</span>(start.y / cell_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> start_key = list.<span class="built_in">size</span>();</span><br><span class="line">    list.<span class="built_in">push_back</span>(start);</span><br><span class="line">    grids[row][col] = start_key;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; active_list;</span><br><span class="line">    active_list.<span class="built_in">push_back</span>(start_key);</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> r = threshold;</span><br><span class="line">    <span class="keyword">while</span> (active_list.<span class="built_in">size</span>() &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在已经有的采样集合中取一个点, 在这个点周围生成新的采样点</span></span><br><span class="line">        <span class="keyword">auto</span> key = active_list[Random::<span class="built_in">Range</span>(active_list.<span class="built_in">size</span>())];</span><br><span class="line">        <span class="comment">// auto key = active_list[0];</span></span><br><span class="line">        <span class="keyword">auto</span> point = list[key];</span><br><span class="line">        <span class="type">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int32_t</span> i = <span class="number">0</span>; i &lt; max_retry; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> direct = Random::<span class="built_in">InsideUnitSphere</span>();</span><br><span class="line">            <span class="comment">// 给原有的采样点 point 加上一个距离 [r, 2r) 的随机向量，成为新的采样点</span></span><br><span class="line">            <span class="keyword">auto</span> new_point = point + ((direct.<span class="built_in">Normalized</span>() * r) + (direct * r));</span><br><span class="line">            <span class="keyword">if</span> ((new_point.x &lt; <span class="number">0</span> || new_point.x &gt;= range.x) ||</span><br><span class="line">                (new_point.y &lt; <span class="number">0</span> || new_point.y &gt;= range.y))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            col = std::<span class="built_in">floor</span>(new_point.x / cell_size);</span><br><span class="line">            row = std::<span class="built_in">floor</span>(new_point.y / cell_size);</span><br><span class="line">            <span class="keyword">if</span> (grids[row][col] != <span class="number">-1</span>) <span class="comment">// 区块内已经有采样点类</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查新采样点周围区块是否存在距离小于 threshold 的点</span></span><br><span class="line">            <span class="type">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int32_t</span> min_r = std::<span class="built_in">floor</span>((new_point.y - threshold) / cell_size);</span><br><span class="line">            <span class="type">int32_t</span> max_r = std::<span class="built_in">floor</span>((new_point.y + threshold) / cell_size);</span><br><span class="line">            <span class="type">int32_t</span> min_c = std::<span class="built_in">floor</span>((new_point.x - threshold) / cell_size);</span><br><span class="line">            <span class="type">int32_t</span> max_c = std::<span class="built_in">floor</span>((new_point.x + threshold) / cell_size);</span><br><span class="line">            [&amp;]() &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int32_t</span> r = min_r; r &lt;= max_r; r++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= rows)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int32_t</span> c = min_c; c &lt;= max_c; c++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (c &lt; <span class="number">0</span> || c &gt;= cols)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="type">int32_t</span> point_key = grids[r][c];</span><br><span class="line">                        <span class="keyword">if</span> (point_key != <span class="number">-1</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">auto</span> round_point = list[point_key];</span><br><span class="line">                            <span class="keyword">auto</span> dist = (round_point - new_point).<span class="built_in">Magnitude</span>();</span><br><span class="line">                            <span class="keyword">if</span> (dist &lt; threshold)</span><br><span class="line">                            &#123;</span><br><span class="line">                                ok = <span class="literal">false</span>;</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// 当 ok 为 false 后，后续的循环检测都没有意义的了，</span></span><br><span class="line">                            <span class="comment">// 使用 return 跳出两层循环。</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 新采样点成功采样</span></span><br><span class="line">            <span class="keyword">if</span> (ok)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> new_point_key = list.<span class="built_in">size</span>();</span><br><span class="line">                list.<span class="built_in">push_back</span>(new_point);</span><br><span class="line">                grids[row][col] = new_point_key;</span><br><span class="line">                active_list.<span class="built_in">push_back</span>(new_point_key);</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!found)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = std::<span class="built_in">find</span>(active_list.<span class="built_in">begin</span>(), active_list.<span class="built_in">end</span>(), key);</span><br><span class="line">            <span class="keyword">if</span> (iter != active_list.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                active_list.<span class="built_in">erase</span>(iter);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace Random</span></span><br></pre></td></tr></table></figure><p>代码量不少，上方的 Vec2 其实不是必要的，可以替换成只有两个元素的 vector<int> 或者是简单的结构体替代，算法本体中的一些向量运算也可以直接写表达式，不需要调用函数，代码会少一点点。多写个 Vec2 class 单纯就是个人喜好。</p><p>下面写个 mian 函数测试下执行效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result = Random::<span class="built_in">FastPoissonDiscSampling</span>(&#123;<span class="number">100</span>, <span class="number">100</span>&#125;, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : result)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; p.x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; p.y &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">24</span>,<span class="number">97</span>)</span><br><span class="line">(<span class="number">20.5812</span>,<span class="number">88.8276</span>)</span><br><span class="line">(<span class="number">29.733</span>,<span class="number">82.2709</span>)</span><br><span class="line">(<span class="number">13.8322</span>,<span class="number">79.9774</span>)</span><br><span class="line">(<span class="number">12.2875</span>,<span class="number">91.2487</span>)</span><br><span class="line">(<span class="number">16.9858</span>,<span class="number">99.2597</span>)</span><br><span class="line">(<span class="number">8.35998</span>,<span class="number">99.4975</span>)</span><br><span class="line">(<span class="number">29.1551</span>,<span class="number">89.5978</span>)</span><br><span class="line">(<span class="number">33.6267</span>,<span class="number">72.4279</span>)</span><br><span class="line">(<span class="number">22.9181</span>,<span class="number">82.0951</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>把打印的结果复制到一个数学可视化网站 desmos.com上看看效果。还是很不错的。<br><img src="/images/202105/fpd-sampling-result.png" alt="结果"></p><p>通过调整算法本体中的 max_retry 变量的值，可以调整是要更快的运行速度，还是要能填满所有的区块。max_retry  的值越小，运行速度就越快，但代价就是没法保证每一个区块都被填充随机点。前面提到的论文中说一般设置为 30，基本上就能保证每一个区块都存在随机点。</p><p>(●’◡’●)</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
